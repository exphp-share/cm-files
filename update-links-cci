#!/usr/bin/env python3

# This script generates files in modulefiles/ that dispatch to one of the modulefiles in apps/
# based on the current machine's architecture.
#
# This is similar to the 'update-links' script, but the need to deal with multiple architectures on cci
# prevents us from simply creating symlinks.

import os
import re
import typing as tp
import sys
from pathlib import Path
from collections import defaultdict

# name of a file that, when seen in the apps/ directory, is a file that should be linked to from modulefiles/
LINKABLE_MODFILE_NAME = 'modulefile.lua'

def main():
    import argparse
    p = argparse.ArgumentParser(description='Updates autogenerated modulefiles in cm/modulefiles')
    p.add_argument('--dry-run', action='store_true', help='Only report changes, without actually performing them.')
    args = p.parse_args()

    # parent and THEN resolve, so that the we can symlink to this script from somewhere else
    cm_dir = Path(__file__).parent.resolve()
    _main(
        modules_root=cm_dir / 'modulefiles',
        apps_root=cm_dir / 'apps',
        dry_run=args.dry_run,
    )

def _main(modules_root, apps_root, dry_run):
    context = gather_context(apps_root=apps_root, modules_root=modules_root)

    delete_files_with_no_links(context, modules_root=modules_root, dry_run=dry_run)

    if not dry_run:
        remove_empty_subdirs(apps_root)

    generate_new_linkfiles(context, modules_root=modules_root, dry_run=dry_run)

# ==============================================================================
# info gathering stage

def gather_context(apps_root, modules_root):
    linkable_tree = gather_linkable_modfiles(apps_root)
    currently_linked_tree, skip_modfile_reasons = gather_currently_linked_modfiles(modules_root)

    return ScriptContext(
        linkable_tree=linkable_tree,
        currently_linked_tree=currently_linked_tree,
        skip_modfile_reasons=skip_modfile_reasons,
    )

class LinkedModfile(tp.NamedTuple):
    arch: str
    app_abspath: Path
LinkTree = tp.Dict[str, tp.List[LinkedModfile]]

class ScriptContext(tp.NamedTuple):
    linkable_tree: LinkTree
    currently_linked_tree: LinkTree
    skip_modfile_reasons: tp.Dict[str, str]

def gather_linkable_modfiles(apps_root) -> LinkTree:
    out = defaultdict(list)
    for dirpath, dirs, files in os.walk(apps_root):
        if LINKABLE_MODFILE_NAME in files:
            app_abspath = Path(dirpath) / LINKABLE_MODFILE_NAME  # e.g. /cm/apps/ppc64le/cmake/3.10.0/modulefile.lua
            app_stem = Path(dirpath).relative_to(apps_root)  # e.g. ppc64le/cmake/3.10.0
            arch = app_stem.parts[0]  # e.g. ppc64le
            module_stem = Path(*app_stem.parts[1:])  # e.g. cmake/3.10.0
            module_relpath = module_stem.with_name(module_stem.name + '.lua')  # e.g. cmake/3.10.0.lua

            out[module_relpath].append(LinkedModfile(arch=arch, app_abspath=app_abspath))

    # un-defaultdict-ify output
    return dict(out)

AUTOGENERATED_HEADER_TEXT = '''
-- !! GENERATED BY update-links-cci !!
-- !! DO NOT EDIT THIS FILE, YOUR EDITS WILL BE LOST !!
'''[1:]

def gather_currently_linked_modfiles(modules_root) -> tp.Tuple[LinkTree, tp.Dict[str, str]]:
    out = {}
    skip_modfile_reasons = {}
    for dirpath, dirs, files in os.walk(modules_root):
        for file in files:
            path = Path(dirpath) / file
            if path.suffix == '.lua':
                module_abspath = Path(dirpath) / file  # e.g. /cm/modulefiles/cmake/3.10.0.lua
                module_relpath = module_abspath.relative_to(modules_root)  # e.g. cmake/3.10.0.lua

                # If the file isn't auto-generated, we don't want to regenerate it or delete it
                if not open(module_abspath).read().startswith(AUTOGENERATED_HEADER_TEXT):
                    skip_modfile_reasons[module_relpath] = "could not identify as autogenerated"
                    continue

                arch_links = list(get_existing_links(module_abspath))
                if arch_links:
                    out[module_relpath] = arch_links
    return out, skip_modfile_reasons

PARSE_LINK_REGEX = re.compile(r'^ *(?P<arch>\w+) *= *"(?P<path>[^"]+)",? *-- linkline$')
def get_existing_links(path) -> tp.Iterator[LinkedModfile]:
    for line in open(path):
        match = PARSE_LINK_REGEX.match(line)
        if match:
            yield LinkedModfile(arch=match.group('arch'), app_abspath=Path(match.group('path')))

# ==============================================================================
# action performing stage

def delete_files_with_no_links(context: 'ScriptContext', modules_root, dry_run):
    # Delete modfiles that no longer have any arch links.
    for module_relpath in context.currently_linked_tree:
        module_abspath = Path(modules_root) / module_relpath
        if module_relpath not in context.linkable_tree:
            info(f'Deleting {module_abspath}')
            if not dry_run:
                os.unlink(module_abspath)

def remove_empty_subdirs(root):
    for dirpath, dirs, files in os.walk(root, topdown=False):
        if not dirs and not files:
            if Path(dirpath) != Path(root):
                os.rmdir(dirpath)

def generate_new_linkfiles(context: ScriptContext, modules_root, dry_run):
    for module_relpath in context.linkable_tree:
        module_abspath = Path(modules_root) / module_relpath
        if module_relpath in context.skip_modfile_reasons:
            info(f'Skipping {module_abspath}: {context.skip_modfile_reasons[module_relpath]}')
            continue
        existing_links = context.currently_linked_tree.get(module_relpath, [])

        new_links = [link for link in context.linkable_tree[module_relpath] if link not in existing_links]
        group_header = f'Linking {module_abspath}'
        for is_first, link in with_is_first(new_links):
            info(group_header if is_first else ' ' * len(group_header), end='')
            info(f' -> {link.app_abspath}')

        text = generate_linked_modfile_text(context.linkable_tree[module_relpath])
        if not dry_run:
            module_abspath.parent.mkdir(parents=True, exist_ok=True)
            with open(module_abspath, 'w') as f:
                f.write(text)

def generate_linked_modfile_text(links: tp.Sequence[LinkedModfile]):
    link_lines = '\n'.join(f'  {link.arch} = "{link.app_abspath}", -- linkline' for link in links)
    return AUTOGENERATED_HEADER_TEXT + f'''
function shell(str)
  return string.gsub(subprocess(str), '%s*$', '')
end
local arch = shell("uname -m")
local links = {{
{link_lines}
}}

local actualModfile = links[arch]
if not actualModfile then
  LmodError("Not available for architecture "..arch)
end
loadfile(actualModfile)()
'''

def info(*args, **kw):
    print(*args, **kw, file=sys.stderr)

def with_is_first(iter):
    for i, x in enumerate(iter):
        yield i == 0, x

# ==============================================================================

if __name__ == '__main__':
    main()
